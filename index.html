<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Robot Planar 2 GDL — Movimiento Articular Natural</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
:root {
  --bg: #f4f6fb;
  --primary: #007bff;
  --green: #28a745;
  --orange: #ff7b00;
  --gray: #555;
  --border: #ccd4e0;
  --card: #ffffff;
}

body {
  font-family: "Segoe UI", Roboto, sans-serif;
  background: var(--bg);
  margin: 0;
  color: var(--gray);
  text-align: center;
}

header {
  background: var(--primary);
  color: white;
  padding: 20px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}

main {
  max-width: 1200px;
  margin: 20px auto;
  background: var(--card);
  border-radius: 10px;
  padding: 20px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.08);
}

section {
  margin-bottom: 30px;
}

h2, h3 {
  color: var(--primary);
}

#robotCanvas {
  width: 800px;
  height: 800px;
  max-width: 100%;
  border: 2px solid var(--border);
  background: white;
  border-radius: 10px;
  display: block;
  margin: 0 auto 15px;
}

.input-group {
  margin: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
}

input[type=range] {
  width: 250px;
}

input[type=number], select {
  padding: 6px;
  border: 1px solid var(--border);
  border-radius: 6px;
}

button {
  padding: 10px 16px;
  border: none;
  border-radius: 6px;
  color: white;
  background: var(--green);
  margin: 5px;
  cursor: pointer;
  transition: background 0.2s;
}
button:hover {
  background: #218838;
}

.btn-secondary {
  background: var(--primary);
}
.btn-danger {
  background: #dc3545;
}

#status {
  font-size: 15px;
  margin-top: 10px;
  color: #333;
}

.chart-container {
  width: 90%;
  max-width: 900px;
  margin: 20px auto;
}
</style>
</head>
<body>

<header>
  <h1>Robot Planar 2 GDL — Movimiento Articular Natural</h1>
  <p>Simulación con control cinemático, modo de codo y visualización en tiempo real</p>
</header>

<main>
  <section>
    <h2>Panel de Control</h2>
    <div class="input-group">
      <label>Xd (m):</label>
      <input type="range" id="sliderX" min="-0.26" max="0.26" step="0.001" value="0.14">
      <input type="number" id="xd" min="-0.26" max="0.26" step="0.001" value="0.14">
    </div>
    <div class="input-group">
      <label>Yd (m):</label>
      <input type="range" id="sliderY" min="-0.26" max="0.26" step="0.001" value="0.14">
      <input type="number" id="yd" min="-0.26" max="0.26" step="0.001" value="0.14">
    </div>
    <div class="input-group">
      <label>Duración (s):</label>
      <input type="range" id="dur" min="0.5" max="20" step="0.1" value="6">
      <input type="number" id="durNum" min="0.5" max="20" step="0.1" value="6">
    </div>
    <div class="input-group">
      <label>Configuración:</label>
      <select id="elbowMode">
        <option value="auto" selected>Automático</option>
        <option value="up">Codo arriba</option>
        <option value="down">Codo abajo</option>
      </select>
    </div>
    <div>
      <button id="moverBtn">Mover TCP</button>
      <button id="inicialBtn" class="btn-secondary">Posición Inicial</button>
      <button id="clearBtn" class="btn-danger">Limpiar Trayectoria</button>
    </div>
  </section>

  <section>
    <h2>Visualización del Robot</h2>
    <canvas id="robotCanvas" width="800" height="800"></canvas>
    <div id="status">q₁ = 0.000 rad | q₂ = 1.571 rad | X = 0.140 m | Y = 0.140 m</div>
  </section>

  <section>
    <h2>Gráficas de Movimiento</h2>
    <div class="chart-container"><canvas id="chartQ1"></canvas></div>
    <div class="chart-container"><canvas id="chartQ2"></canvas></div>
  </section>
</main>

<script>
/* === Parámetros principales === */
const L1=0.12,L2=0.12,TOOL=0.02,L2E=L2+TOOL,SCALE=1000;
const L_REACH=L1+L2E;
const canvas=document.getElementById('robotCanvas'),ctx=canvas.getContext('2d');
const center={x:canvas.width/2,y:canvas.height/2};
let q1=0,q2=Math.PI/2,pathPoints=[],animating=false;

/* === Utilidades matemáticas === */
function wrapToPi(a){a=((a+Math.PI)%(2*Math.PI));if(a<0)a+=2*Math.PI;return a-Math.PI;}
function angleDiff(a,b){let d=wrapToPi(b-a);return d;}
function clamp(v,lo,hi){return Math.max(lo,Math.min(hi,v));}

/* === Cinemática === */
function forwardKinematics(q1v,q2v){
  const x1=L1*Math.cos(q1v),y1=L1*Math.sin(q1v);
  const x2=x1+L2*Math.cos(q1v+q2v),y2=y1+L2*Math.sin(q1v+q2v);
  const xt=x1+L2E*Math.cos(q1v+q2v),yt=y1+L2E*Math.sin(q1v+q2v);
  return{x1,y1,x2,y2,xt,yt};
}
function inverseKinematicsAll(x,y){
  const r2=x*x+y*y,denom=2*L1*L2E,epsilon=1e-9;
  const cosQ2=(r2-L1*L1-L2E*L2E)/(denom);
  if(cosQ2<-1-epsilon||cosQ2>1+epsilon)return null;
  const q2a=Math.acos(clamp(cosQ2,-1,1)),q2b=-q2a;
  const q1a=Math.atan2(y,x)-Math.atan2(L2E*Math.sin(q2a),L1+L2E*Math.cos(q2a));
  const q1b=Math.atan2(y,x)-Math.atan2(L2E*Math.sin(q2b),L1+L2E*Math.cos(q2b));
  return[{q1:wrapToPi(q1a),q2:wrapToPi(q2a)},{q1:wrapToPi(q1b),q2:wrapToPi(q2b)}];
}

/* === Dibujo === */
function toCanvas(p){return{x:center.x+p.x*SCALE,y:center.y-p.y*SCALE};}
function drawGrid(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle='#e5e9f0';ctx.lineWidth=1;
  for(let g=-0.4;g<=0.4;g+=0.02){
    const vx=center.x+g*SCALE,vy=center.y-g*SCALE;
    ctx.beginPath();ctx.moveTo(vx,0);ctx.lineTo(vx,canvas.height);ctx.stroke();
    ctx.beginPath();ctx.moveTo(0,vy);ctx.lineTo(canvas.width,vy);ctx.stroke();
  }
  ctx.strokeStyle='#333';ctx.lineWidth=1.3;
  ctx.beginPath();ctx.moveTo(center.x,0);ctx.lineTo(center.x,canvas.height);ctx.stroke();
  ctx.beginPath();ctx.moveTo(0,center.y);ctx.lineTo(canvas.width,center.y);ctx.stroke();
  ctx.beginPath();ctx.strokeStyle='rgba(0,0,0,.15)';ctx.arc(center.x,center.y,L_REACH*SCALE,0,2*Math.PI);ctx.stroke();
}
function drawPath(){
  if(pathPoints.length<2)return;
  ctx.beginPath();ctx.strokeStyle='rgba(255,0,0,0.6)';
  ctx.setLineDash([5,5]);ctx.lineWidth=2;
  let c0=toCanvas(pathPoints[0]);ctx.moveTo(c0.x,c0.y);
  for(let i=1;i<pathPoints.length;i++){
    let p=toCanvas(pathPoints[i]);ctx.lineTo(p.x,p.y);
  }
  ctx.stroke();ctx.setLineDash([]);
}
function drawRobot(q1v,q2v){
  drawGrid();drawPath();
  const fk=forwardKinematics(q1v,q2v);
  const O=toCanvas({x:0,y:0}),P1=toCanvas({x:fk.x1,y:fk.y1});
  const P2=toCanvas({x:fk.x2,y:fk.y2}),TCP=toCanvas({x:fk.xt,y:fk.yt});
  ctx.lineWidth=6;ctx.strokeStyle='#3a7bd5';ctx.beginPath();ctx.moveTo(O.x,O.y);ctx.lineTo(P1.x,P1.y);ctx.stroke();
  ctx.strokeStyle='#3fa47a';ctx.beginPath();ctx.moveTo(P1.x,P1.y);ctx.lineTo(P2.x,P2.y);ctx.stroke();
  ctx.lineWidth=4;ctx.strokeStyle='#ff7b00';ctx.beginPath();ctx.moveTo(P2.x,P2.y);ctx.lineTo(TCP.x,TCP.y);ctx.stroke();
  ctx.fillStyle='#111';[O,P1,P2,TCP].forEach(p=>{ctx.beginPath();ctx.arc(p.x,p.y,5,0,2*Math.PI);ctx.fill();});
  document.getElementById("status").innerText = 
    `q₁ = ${q1v.toFixed(3)} rad | q₂ = ${q2v.toFixed(3)} rad | X = ${fk.xt.toFixed(3)} m | Y = ${fk.yt.toFixed(3)} m`;
}

/* === Trayectorias === */
function getQuinticCoeffs(q0,qf,T){
  const dq=qf-q0;
  return[q0,0,0,10*dq/(T**3),-15*dq/(T**4),6*dq/(T**5)];
}
function evalQuintic(c,t){const[a0,a1,a2,a3,a4,a5]=c;return a0+a1*t+a2*t*t+a3*t**3+a4*t**4+a5*t**5;}

/* === Gráficas === */
const q1Chart=new Chart(document.getElementById('chartQ1'),{
  type:'line',
  data:{labels:[],datasets:[{label:'q₁ (rad)',data:[],borderColor:'#3a7bd5',fill:false}]},
  options:{animation:false,scales:{x:{title:{display:true,text:'t (s)'}},y:{title:{display:true,text:'rad'}}}}
});
const q2Chart=new Chart(document.getElementById('chartQ2'),{
  type:'line',
  data:{labels:[],datasets:[{label:'q₂ (rad)',data:[],borderColor:'#3fa47a',fill:false}]},
  options:{animation:false,scales:{x:{title:{display:true,text:'t (s)'}},y:{title:{display:true,text:'rad'}}}}
});
function chartsReset(){q1Chart.data.labels=[];q1Chart.data.datasets[0].data=[];q2Chart.data.labels=[];q2Chart.data.datasets[0].data=[];q1Chart.update();q2Chart.update();}
function chartsPush(t,q1v,q2v){q1Chart.data.labels.push(t.toFixed(2));q1Chart.data.datasets[0].data.push(q1v);q2Chart.data.labels.push(t.toFixed(2));q2Chart.data.datasets[0].data.push(q2v);q1Chart.update();q2Chart.update();}

/* === Movimiento === */
function moveArticularTo(xd,yd,T){
  if(animating)return;
  if(Math.hypot(xd,yd)>L_REACH+1e-6){alert('Punto fuera del alcance.');return;}
  const sols=inverseKinematicsAll(xd,yd);
  if(!sols)return alert('Sin solución IK.');
  const mode=document.getElementById('elbowMode').value;
  let target=mode==='up'?sols[1]:mode==='down'?sols[0]:sols.reduce((a,b)=>Math.abs(angleDiff(b.q1,q1))+Math.abs(angleDiff(b.q2,q2))<Math.abs(angleDiff(a.q1,q1))+Math.abs(angleDiff(a.q2,q2))?b:a);
  const c1=getQuinticCoeffs(q1,target.q1,T),c2=getQuinticCoeffs(q2,target.q2,T);
  chartsReset();pathPoints=[];animating=true;
  const t0=performance.now();
  function step(now){
    const t=(now-t0)/1000;const tt=clamp(t,0,T);
    q1=wrapToPi(evalQuintic(c1,tt));q2=wrapToPi(evalQuintic(c2,tt));
    const fk=forwardKinematics(q1,q2);
    pathPoints.push({x:fk.xt,y:fk.yt});
    drawRobot(q1,q2);chartsPush(tt,q1,q2);
    if(t<T){requestAnimationFrame(step);}else{animating=false;drawRobot(q1,q2);}
  }
  requestAnimationFrame(step);
}

/* === Interfaz === */
function bind(a,b){a.addEventListener('input',()=>b.value=a.value);b.addEventListener('input',()=>a.value=b.value);}
const sliderX=document.getElementById('sliderX'),inputX=document.getElementById('xd');
const sliderY=document.getElementById('sliderY'),inputY=document.getElementById('yd');
const dur=document.getElementById('dur'),durNum=document.getElementById('durNum');
bind(sliderX,inputX);bind(sliderY,inputY);bind(dur,durNum);
moverBtn.onclick=()=>moveArticularTo(parseFloat(xd.value),parseFloat(yd.value),parseFloat(dur.value));
inicialBtn.onclick=()=>moveArticularTo(0.14,0.14,parseFloat(dur.value));
clearBtn.onclick=()=>{q1=0;q2=Math.PI/2;pathPoints=[];chartsReset();drawRobot(q1,q2);}
drawRobot(q1,q2);
</script>
</body>
</html>
