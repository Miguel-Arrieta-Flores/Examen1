<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Robot Planar 2 GDL — Movimiento Articular Natural</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
:root{--accent:#007bff;--ok:#28a745;--warn:#dc3545;--muted:#6c757d}
*{box-sizing:border-box} body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#f4f4f9;color:#222}
header{background:var(--accent);color:#fff;padding:16px;text-align:center}
main{max-width:1200px;margin:20px auto;padding:12px}
.row{display:flex;flex-wrap:wrap;gap:16px;justify-content:center}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
.controls{flex:1 1 380px;min-width:320px;max-width:460px}
.canvas-card{flex:2 1 640px;min-width:540px}
.charts{flex:1 1 360px;min-width:320px;max-width:460px}
.control-row{display:grid;grid-template-columns:120px 1fr 80px;gap:8px;align-items:center;margin:8px 0}
input[type=range]{width:100%} input[type=number]{padding:6px;border-radius:8px;border:1px solid #ccc}
button{padding:10px 14px;border-radius:10px;border:0;color:#fff;font-weight:600;cursor:pointer}
.btn-primary{background:var(--ok)} .btn-secondary{background:var(--accent)} .btn-danger{background:var(--warn)}
#robotCanvas{width:800px;height:800px;max-width:100%;border:2px solid #333;background:#fff;border-radius:8px;display:block;margin:12px auto}
.legend{display:flex;gap:12px;justify-content:center;flex-wrap:wrap;color:var(--muted);font-size:13px}
.chip{background:#f8f9fa;padding:6px 10px;border-radius:999px;border:1px solid #eee;display:inline-flex;align-items:center;gap:8px}
.chip i{width:20px;height:0;border-top:4px solid} .i-l1{border-color:#007bff} .i-l2{border-color:#28a745} .i-tool{border-color:#ff7b00} .i-traj{border-color:rgba(255,0,0,.6)}
@media(max-width:920px){.row{flex-direction:column;align-items:stretch}.canvas-card{order:-1}}
</style>
</head>
<body>
<header>
  <h1>Robot Planar 2 GDL — Movimiento Articular Natural</h1>
  <p style="margin:4px 0 0;opacity:.9">El sistema elige la solución (codo arriba/abajo) que minimiza el cambio articular y genera una animación suave.</p>
</header>

<main>
  <div class="row">
    <!-- Controls -->
    <section class="card controls">
      <h3>Panel de control (cm)</h3>

      <div class="control-row">
        <label for="sliderX">Xd:</label>
        <input type="range" id="sliderX" min="-24" max="24" step="0.1" value="14">
        <input type="number" id="xd" min="-24" max="24" step="0.1" value="14">
      </div>

      <div class="control-row">
        <label for="sliderY">Yd:</label>
        <input type="range" id="sliderY" min="-24" max="24" step="0.1" value="14">
        <input type="number" id="yd" min="-24" max="24" step="0.1" value="14">
      </div>

      <div class="control-row">
        <label for="dur">Duración (s):</label>
        <input type="range" id="dur" min="0.5" max="12" step="0.1" value="6">
        <input type="number" id="durNum" min="0.5" max="12" step="0.1" value="6">
      </div>

      <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:12px">
        <button id="moverBtn" class="btn-primary">Mover TCP (Articular)</button>
        <button id="inicialBtn" class="btn-secondary">Ir a Posición Inicial (14,14)</button>
        <button id="clearBtn" class="btn-danger">Borrar Tray. & Gráficas</button>
      </div>
    </section>

    <!-- Canvas -->
    <section class="card canvas-card">
      <h3>Plano cartesiano y robot</h3>
      <canvas id="robotCanvas" width="800" height="800"></canvas>
      <div class="legend" style="margin-top:8px">
        <span class="chip"><i class="i-l1"></i>Eslabón 1 (12 cm)</span>
        <span class="chip"><i class="i-l2"></i>Eslabón 2 (12 cm)</span>
        <span class="chip"><i class="i-tool"></i>Herramienta (2 cm)</span>
        <span class="chip"><i class="i-traj"></i>Trayectoria TCP (movimiento)</span>
      </div>
      <p style="margin:8px 0 0;color:#6c757d;font-size:13px">Escala: 1 cm = 10 px — círculo: L1 + (L2+herramienta)</p>
    </section>

    <!-- Charts -->
    <section class="card charts">
      <h3>Gráficas q₁(t) y q₂(t)</h3>
      <div style="margin-top:10px"><canvas id="chartQ1"></canvas></div>
      <div style="margin-top:12px"><canvas id="chartQ2"></canvas></div>
    </section>
  </div>
</main>

<script>
/* ======================
   Parámetros y estado
   ====================== */
const L1 = 12, L2 = 12, TOOL = 2;
const L2E = L2 + TOOL;
const SCALE = 10; // px por cm
const canvas = document.getElementById('robotCanvas'), ctx = canvas.getContext('2d');
const center = { x: canvas.width/2, y: canvas.height/2 };

let q1 = 0, q2 = Math.PI/2; // posición articular actual
let pathPoints = [];        // trayectoria del TCP durante la animación
let animating = false;

/* ====== Helpers angulares ====== */
function wrapToPi(a){ // [-pi,pi]
  a = ((a + Math.PI) % (2*Math.PI));
  if(a < 0) a += 2*Math.PI;
  return a - Math.PI;
}
function angleDiff(a,b){ // b - a wrapped to [-pi,pi]
  let d = wrapToPi(b - a);
  return d;
}
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

/* ====== Cinemática directa e inversa (L2 + TOOL considerado) ====== */
function forwardKinematics(q1v, q2v){
  const x1 = L1*Math.cos(q1v), y1 = L1*Math.sin(q1v);
  const x2 = x1 + L2*Math.cos(q1v + q2v), y2 = y1 + L2*Math.sin(q1v + q2v); // fin L2 (visual)
  const xt = x1 + L2E*Math.cos(q1v + q2v), yt = y1 + L2E*Math.sin(q1v + q2v); // TCP (efector)
  return { x1,y1,x2,y2,xt,yt };
}

// returns array of solutions [{q1,q2}, ...] or null
function inverseKinematicsAll(x, y){
  const r2 = x*x + y*y;
  const denom = 2 * L1 * L2E;
  const cosQ2 = (r2 - L1*L1 - L2E*L2E) / denom;
  if(cosQ2 < -1 || cosQ2 > 1) return null;
  const acosV = Math.acos(clamp(cosQ2, -1, 1));
  const q2a = acosV;      // elbow-down (positive)
  const q2b = -acosV;     // elbow-up
  const q1a = Math.atan2(y,x) - Math.atan2(L2E*Math.sin(q2a), L1 + L2E*Math.cos(q2a));
  const q1b = Math.atan2(y,x) - Math.atan2(L2E*Math.sin(q2b), L1 + L2E*Math.cos(q2b));
  return [{ q1: wrapToPi(q1a), q2: wrapToPi(q2a) }, { q1: wrapToPi(q1b), q2: wrapToPi(q2b) }];
}

/* ====== Dibujo ====== */
function toCanvas(pt){ return { x: center.x + pt.x*SCALE, y: center.y - pt.y*SCALE }; }

function drawGrid(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // grid
  ctx.strokeStyle = '#f0f0f0'; ctx.lineWidth = 1;
  for(let g=-40; g<=40; g+=2){
    const vx = center.x + g*SCALE;
    const vy = center.y - g*SCALE;
    ctx.beginPath(); ctx.moveTo(vx,0); ctx.lineTo(vx,canvas.height); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,vy); ctx.lineTo(canvas.width,vy); ctx.stroke();
  }
  // axes
  ctx.strokeStyle = '#000'; ctx.lineWidth = 1.4;
  ctx.beginPath(); ctx.moveTo(center.x,0); ctx.lineTo(center.x,canvas.height); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,center.y); ctx.lineTo(canvas.width,center.y); ctx.stroke();
  // reach circle
  ctx.beginPath(); ctx.strokeStyle='rgba(0,0,0,.12)'; ctx.lineWidth=1.2;
  ctx.arc(center.x, center.y, (L1 + L2E)*SCALE, 0, 2*Math.PI); ctx.stroke();
}

function drawPath(){
  if(pathPoints.length < 2) return;
  ctx.beginPath(); ctx.strokeStyle = 'rgba(255,0,0,0.6)'; ctx.lineWidth = 2;
  const c0 = toCanvas(pathPoints[0]); ctx.moveTo(c0.x, c0.y);
  for(let i=1;i<pathPoints.length;i++){ const p = toCanvas(pathPoints[i]); ctx.lineTo(p.x,p.y); }
  ctx.stroke();
}

function drawRobot(q1v, q2v){
  drawGrid();
  drawPath();
  const fk = forwardKinematics(q1v, q2v);
  const O = toCanvas({x:0,y:0}), P1 = toCanvas({x:fk.x1,y:fk.y1}), P2 = toCanvas({x:fk.x2,y:fk.y2}), TCP = toCanvas({x:fk.xt,y:fk.yt});
  // L1
  ctx.strokeStyle = '#007bff'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(O.x,O.y); ctx.lineTo(P1.x,P1.y); ctx.stroke();
  // L2 (visual)
  ctx.strokeStyle = '#28a745'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(P1.x,P1.y); ctx.lineTo(P2.x,P2.y); ctx.stroke();
  // Tool (visual)
  ctx.strokeStyle = '#ff7b00'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(P2.x,P2.y); ctx.lineTo(TCP.x,TCP.y); ctx.stroke();
  // joints
  ctx.fillStyle = '#000';
  [O,P1,P2,TCP].forEach(p=>{ ctx.beginPath(); ctx.arc(p.x,p.y,5,0,2*Math.PI); ctx.fill(); });
}

/* ====== Quintic trajectory coefficients for joint-space motion ======
   q(t) = a0 + a1 t + a2 t^2 + a3 t^3 + a4 t^4 + a5 t^5
   with q(0)=q0, q(T)=qf, qdot(0)=qdot(T)=0, qddot(0)=qddot(T)=0
*/
function getQuinticCoeffs(q0, qf, T){
  const a0 = q0;
  const a1 = 0;
  const a2 = 0;
  const a3 = (10*(qf - q0)) / (T**3);
  const a4 = (-15*(qf - q0)) / (T**4);
  const a5 = (6*(qf - q0)) / (T**5);
  return [a0,a1,a2,a3,a4,a5];
}
function evalQuintic(coeffs, t){
  const [a0,a1,a2,a3,a4,a5] = coeffs;
  return a0 + a1*t + a2*t*t + a3*t**3 + a4*t**4 + a5*t**5;
}

/* ====== Charts (Chart.js) ====== */
const q1Chart = new Chart(document.getElementById('chartQ1'), {
  type:'line',
  data:{ labels:[], datasets:[{ label:'q₁ (rad)', data:[], borderColor:'#007bff', fill:false }]},
  options:{ animation:false, scales:{ x:{ title:{display:true,text:'Tiempo (s)'}}, y:{ title:{display:true,text:'rad'} } } }
});
const q2Chart = new Chart(document.getElementById('chartQ2'), {
  type:'line',
  data:{ labels:[], datasets:[{ label:'q₂ (rad)', data:[], borderColor:'#28a745', fill:false }]},
  options:{ animation:false, scales:{ x:{ title:{display:true,text:'Tiempo (s)'}}, y:{ title:{display:true,text:'rad'} } } }
});
function chartsReset(){ q1Chart.data.labels=[]; q1Chart.data.datasets[0].data=[]; q2Chart.data.labels=[]; q2Chart.data.datasets[0].data=[]; q1Chart.update(); q2Chart.update(); }
function chartsPush(t,q1v,q2v){ q1Chart.data.labels.push(t.toFixed(2)); q1Chart.data.datasets[0].data.push(q1v); q2Chart.data.labels.push(t.toFixed(2)); q2Chart.data.datasets[0].data.push(q2v); q1Chart.update(); q2Chart.update(); }

/* ====== Motion: choose solution automatically and animate joint-space quintic ====== */
function moveArticularTo(xd, yd, duration_s){
  if(animating) return;
  // reachability check (use L2E)
  const r = Math.hypot(xd, yd);
  if(r > L1 + L2E + 1e-6){ alert('El punto está fuera del espacio de trabajo.'); return; }

  const sols = inverseKinematicsAll(xd, yd);
  if(!sols){ alert('IK no devolvió solución válida.'); return; }

  // choose solution closest in joint-space to current [q1,q2]
  let best = sols[0];
  let bestDist = Math.abs(angleDiff(q1, sols[0].q1)) + Math.abs(angleDiff(q2, sols[0].q2));
  for(let i=1;i<sols.length;i++){
    const s = sols[i];
    const d = Math.abs(angleDiff(q1,s.q1)) + Math.abs(angleDiff(q2,s.q2));
    if(d < bestDist){ bestDist = d; best = s; }
  }

  // build quintic coeffs for q1 and q2 from t=0..T
  const T = Math.max(0.1, parseFloat(duration_s));
  const coeffs1 = getQuinticCoeffs(q1, best.q1, T);
  const coeffs2 = getQuinticCoeffs(q2, best.q2, T);

  // animate: sample with requestAnimationFrame; use elapsed time
  chartsReset();
  pathPoints = [];
  animating = true;
  const tStart = performance.now();

  function step(now){
    const elapsed = (now - tStart) / 1000;
    const tt = clamp(elapsed, 0, T);
    const q1t = evalQuintic(coeffs1, tt);
    const q2t = evalQuintic(coeffs2, tt);
    q1 = wrapToPi(q1t);
    q2 = wrapToPi(q2t);

    // store TCP position for path drawing
    const fk = forwardKinematics(q1,q2);
    pathPoints.push({ x: fk.xt, y: fk.yt });

    // draw and update plots
    drawRobot(q1,q2);
    chartsPush(tt, q1, q2);

    if(elapsed < T){
      requestAnimationFrame(step);
    } else {
      animating = false;
      // ensure final exactly target
      q1 = best.q1; q2 = best.q2;
      drawRobot(q1,q2);
      chartsPush(T, q1, q2);
    }
  }
  requestAnimationFrame(step);
}

/* ====== UI bindings ====== */
const sliderX = document.getElementById('sliderX'), inputX = document.getElementById('xd');
const sliderY = document.getElementById('sliderY'), inputY = document.getElementById('yd');
const dur = document.getElementById('dur'), durNum = document.getElementById('durNum');

function bind(a,b){ a.addEventListener('input', ()=> b.value = a.value); b.addEventListener('input', ()=> a.value = b.value); }
bind(sliderX, inputX); bind(sliderY, inputY); bind(dur, durNum);

/* Buttons */
document.getElementById('moverBtn').addEventListener('click', ()=>{
  const xd = parseFloat(inputX.value), yd = parseFloat(inputY.value);
  const T = parseFloat(dur.value);
  moveArticularTo(xd, yd, T);
});
document.getElementById('inicialBtn').addEventListener('click', ()=>{
  // move to (14,14)
  moveArticularTo(14,14, parseFloat(dur.value));
});
document.getElementById('clearBtn').addEventListener('click', ()=>{
  pathPoints = []; chartsReset(); drawRobot(q1,q2);
});

/* ====== Init draw ====== */
drawRobot(q1,q2);
</script>
</body>
</html>
